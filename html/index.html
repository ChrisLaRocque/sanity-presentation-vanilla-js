<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body style="font-family: sans-serif">
    <h1 id="title"></h1>
    <p id="body"></p>
  </body>
  <script type="module">
    /**
     * Vanilla JS implementation of Sanity's core-loader for Presentation.
     */
    import {createClient} from 'https://esm.sh/@sanity/client'
    import {createQueryStore} from 'https://esm.sh/@sanity/core-loader'
    import {enableVisualEditing} from 'https://esm.sh/@sanity/visual-editing'

    // Shared config information for Sanity client
    const baseClientConfig = {
      projectId: 'mh3x2u7s',
      dataset: 'production',
      apiVersion: '2024-04-24',
    }

    // GROQ query
    const query = `*[_type=="page"][0]{title, body}`

    // Initialize Sanity client for 'production' data
    const client = createClient(baseClientConfig)

    // Non-presentation data fetching
    const initial = await client.fetch(query)

    // Pass Sanity data to HTML
    if (initial) {
      renderHtml(initial)
    }

    // Populate page with data
    function renderHtml({title, body}) {
      document.querySelector('#title').innerHTML = title || '&nbsp;'
      document.querySelector('#body').innerHTML = body || '&nbsp'
    }
    // TODO - Implement an on/off for presentation. In this example its always on.
    // When in Presentation, enable Stega for overlays
    client.config({stega: {enabled: true, studioUrl: 'http://localhost:3333'}})

    // Initialize queryStore to access fetcherStore + enableLiveMode
    const queryStore = createQueryStore({
      client,
    })

    // I believe the client needs to get passed again because there's no serverClient
    queryStore.enableLiveMode({client})

    // Allow the Studio to connect to overlays
    enableVisualEditing()

    // Fetcherstore fetches data and provides a subscribe method to listen for changes
    const fetcherStore = queryStore.createFetcherStore(query, {}, initial)

    // Listen for changes + re-render HTML in response
    fetcherStore.subscribe(({loading, data}) => {
      if (!loading && data) {
        renderHtml(data)
      }
    })
  </script>
</html>
